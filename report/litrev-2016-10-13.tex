\section{Gunrock}
\begin{itemize}
    \item A data-centric abstraction for graph operations providing higher abstraction level as well as better performance.
    \item A set of flexible API that can be used to express a wide range of graph processing primitives.
    \item A few mechanisms to improve memory efficiency: load balancing and workload management
\end{itemize}

\section{Medusa}
The goal of Medusa framework in the first place is to ease the general graph applications on GPUs.
Here are the major contributions of Medusa.
\begin{itemize}
    \item Edge-Message-Vertex (EMV) model: it provides 6 APIs which used for fine-grained edge and vertex processing.
    \item Memory optimization: Graph aware buffer scheme which avoids the message grouping overhead. 
    \item Multi-GPU support: With vertex and edge replication, the graph is equally partitioned. Multi-hop replication is also discussed. 
\end{itemize}

\section{Dynamic Graph Processing}
Problems of processing dynamic graph with its continuous updates in real-time manner
\begin{itemize}
\item Graph storage: Modification of graph structure is costly
\item Fast response: Widely used global manner cannot achieve real-time processing
\item Workload imbalance: Some vertices update more frequently and consume more computing resource in a certain period of time.
\end{itemize}

Ideas:
\begin{itemize}
\item Random-access graph structure: Hash-based graph partition strategy to enable fine-grained graph updates
\item Incremental graph processing: Vertex-based incremental graph computing model
\item Workload rebalance: Detect hotspots and evaluate their workload, and then rebalance them with greedy algorithms.
\end{itemize}
